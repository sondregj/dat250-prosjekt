package no.hvl.dat250.polls.controllers;

import no.hvl.dat250.polls.config.JwtService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class AuthController {

    @Autowired
    private JwtService jwtService;

    @Autowired
    private AuthenticationManager authenticationManager;

    @PostMapping("/api/auth/login")
    public ResponseEntity<String> login(
        @RequestBody LoginRequest loginRequest
    ) {
        Authentication authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(
                loginRequest.getUsername(),
                loginRequest.getPassword()
            )
        );
        SecurityContextHolder.getContext().setAuthentication(authentication);
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        String jwt = jwtService.generateToken(userDetails);
        return ResponseEntity.ok(jwt);
    }
}

class LoginRequest {

    private String username;
    private String password;

    // Default constructor
    public LoginRequest() {}

    // Constructor with fields
    public LoginRequest(String username, String password) {
        this.username = username;
        this.password = password;
    }

    // Getters and setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
package no.hvl.dat250.polls.controllers;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import no.hvl.dat250.polls.Error.AccessDeniedException;
import no.hvl.dat250.polls.Error.CommonErrors;
import no.hvl.dat250.polls.Error.OperationFailedError;
import no.hvl.dat250.polls.Error.ResourceNotFoundException;
import no.hvl.dat250.polls.Services.PollService;
import no.hvl.dat250.polls.Services.UserService;
import no.hvl.dat250.polls.models.Poll;
import no.hvl.dat250.polls.models.User;

/**
 * PollController
 * @author Jonas Vestbø
 */
@RestController
@RequestMapping("/api/polls")
public class PollController {

    @Autowired 
    PollService service;

    @Autowired
    UserService UserService;

    //Does not need to be logged in
    @GetMapping
    public ResponseEntity<?> getPolls(){
        List<Poll> retrievedPolls = service.getAllPolls();
        if (retrievedPolls.isEmpty()){
            return new ResponseEntity<>(
                    CommonErrors.POLL_NOT_FOUND,
                    HttpStatus.NOT_FOUND
                    );
        }
        return new ResponseEntity<>(retrievedPolls, HttpStatus.OK);
    }

    //Does not need to be logged in
    @GetMapping("/{id}")
    public ResponseEntity<?> getPollById(@PathVariable("id") Long id){
        Optional<Poll> retrievedPoll = service.getPollById(id);
            
        if (retrievedPoll.isEmpty()){
            return new ResponseEntity<>(
                    new ResourceNotFoundException("Could not find requested poll"),
                    HttpStatus.BAD_REQUEST);
        }

        return new ResponseEntity<>(retrievedPoll.get(), HttpStatus.OK);
    }

    @PostMapping
    public ResponseEntity<?> postPoll(@RequestBody Poll poll, Authentication authentication){
        if (authentication == null){
            return new ResponseEntity<>(
                    CommonErrors.NOT_AUTHORIZED,
                    HttpStatus.FORBIDDEN
    // Needs to be logged in
                    );
        }
        Jwt token = (Jwt) authentication.getPrincipal();
        String username = token.getClaimAsString("sub");

        Optional<User> userOPT = UserService.getUserByUsername(username);
        if (userOPT.isEmpty()){
            return new ResponseEntity<>(
                    CommonErrors.USER_NOT_FOUND,
                    HttpStatus.NOT_FOUND
                    );
                                        
        }
        User user = userOPT.get();
        poll.setCreator(user);
        Poll postedPoll = service.addPoll(poll);
        return new ResponseEntity<>(postedPoll, HttpStatus.CREATED);
    }

    @DeleteMapping
    public ResponseEntity<?> removePoll(@RequestBody Poll poll, Authentication authentication){
        Jwt jwt = (Jwt) authentication.getPrincipal();
        String username = jwt.getClaimAsString("sub");
        Optional<Poll> retrievedPoll = service.getPollById(poll.getId());
    
        if (retrievedPoll.isEmpty()){
            return new ResponseEntity<>(new Error("Did not find requested poll"), 
                    HttpStatus.NOT_FOUND);
        }
    
        Poll existingPoll = retrievedPoll.get();
        if (!existingPoll.getCreator().getUsername().equals(username)){
            return new ResponseEntity<>(new Error("You can only delete your own polls"),
                                            HttpStatus.UNAUTHORIZED);
        }
    
        if (!service.deletePoll(retrievedPoll.get())){
            return new ResponseEntity<>(new OperationFailedError("Could not delete poll"), 
                                            HttpStatus.INTERNAL_SERVER_ERROR);
        }
        return new ResponseEntity<>(retrievedPoll.get(), HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> removePollById(@PathVariable Long id, Authentication authentication){
        if (authentication == null){
            return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
        }
        Jwt jwt = (Jwt) authentication.getPrincipal();
        String username = jwt.getClaimAsString("sub");
        Optional<Poll> pollOPT = service.getPollById(id);

        if (pollOPT.isEmpty()){
            return new ResponseEntity<>(new ResourceNotFoundException("Requested poll not found"),
                    HttpStatus.NOT_FOUND);
        }

        Poll poll = pollOPT.get();

        if (!poll.getCreator().getUsername().equals(username)){
            return new ResponseEntity<>(new AccessDeniedException("You can only delete your own polls"),
                    HttpStatus.BAD_REQUEST);
        }

        if (!service.deletePoll(poll)){
            return new ResponseEntity<>(new OperationFailedError("Could not delete poll"),
                    HttpStatus.INTERNAL_SERVER_ERROR);
        }

        return new ResponseEntity<>(poll, HttpStatus.OK);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Poll> updateValidUntil(@PathVariable("id") Long id,
            @RequestBody Poll updatedPoll){
            Poll existingPoll = service.getPollById(id)
               .orElseThrow(() -> new ResourceNotFoundException("Could not find poll"));
    
                existingPoll.setValidUntil(updatedPoll.getValidUntil());
                Poll updated = service.updatePoll(id, existingPoll)
                    .orElseThrow(() -> new ResourceNotFoundException("Could not find poll"));

                    return new ResponseEntity<>(updated, HttpStatus.OK);
            }

    //Needs to be logged in // Maybe not a needed method at all? //Only for admin?
    // @PutMapping("/{id}")
    // public ResponseEntity<Poll> updatePoll(@PathVariable("id") Long id, 
    //         @RequestBody Poll updatedPoll,
    //         Authentication authentication){
    //     Jwt token = (Jwt) authentication.getPrincipal();
    //     String username = token.getClaimAsString("sub");
    //     Poll existingPoll = service.getPollById(id)
    //         .orElseThrow(() -> new ResourceNotFoundException("Poll not found"));
    //
    //     if (!existingPoll.getCreator().getUsername().equals(username)){
    //         throw new AccessDeniedException("You can only modify your own poll");
    //     }
    //     Poll updated = service.updatePoll(id, updatedPoll)
    //         .orElseThrow(() -> new OperationFailedError("Failed to update poll"));
    //
    //     return new ResponseEntity<>(updated, HttpStatus.OK);
    //      
    //
    // }
    
}
package no.hvl.dat250.polls.controllers;

import java.net.http.HttpResponse;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import no.hvl.dat250.polls.Error.CommonErrors;
import no.hvl.dat250.polls.Error.OperationFailedError;
import no.hvl.dat250.polls.Error.ResourceNotFoundException;
import no.hvl.dat250.polls.Services.GuestUserService;
import no.hvl.dat250.polls.Services.UserService;
import no.hvl.dat250.polls.Services.VoteOptionService;
import no.hvl.dat250.polls.Services.VoteService;
import no.hvl.dat250.polls.models.User;
import no.hvl.dat250.polls.models.Vote;
import no.hvl.dat250.polls.models.guestUser;

/**
 * VoteController
 * @author Jonas Vestbø
 */
@RestController
@RequestMapping("/api/votes")
public class VoteController {

    @Autowired VoteService service;
    @Autowired UserService userService;
    @Autowired VoteOptionService voService;
    @Autowired GuestUserService guService;

    @GetMapping("/{id}")
    public ResponseEntity<?> getVoteById(@PathVariable("id") Long id){
        Optional<Vote> retrievedVote = service.getVoteById(id);
        if (retrievedVote.isEmpty()){
            return new ResponseEntity<>(
                    CommonErrors.VOTE_NOT_FOUND,
                    HttpStatus.NOT_FOUND
                    );
        }
        return new ResponseEntity<>(retrievedVote.get(), HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> removeVote(@PathVariable("id") Long id,
            @RequestHeader(value = "GuestId", required = false) String guestId,
            Authentication authentication){
        if (authentication == null && guestId == null){
            return new ResponseEntity<>(CommonErrors.NOT_AUTHORIZED, 
                                            HttpStatus.BAD_REQUEST);
        }

        Optional<Vote> voteOPT = service.getVoteById(id);

        if (voteOPT.isEmpty()){
            return new ResponseEntity<>(CommonErrors.VOTE_NOT_FOUND,
                                        HttpStatus.NOT_FOUND);
        }

        Vote vote = voteOPT.get();

        if (authentication != null){
            Jwt token = (Jwt) authentication.getPrincipal();
            String username = token.getClaimAsString("sub");
            Optional<User> userOPT = userService.getUserByUsername(username);
            if (userOPT.isEmpty()){
                return new ResponseEntity<>(CommonErrors.USER_NOT_FOUND,
                                            HttpStatus.NOT_FOUND);
            }
            User user = userOPT.get();
            if (!vote.getUser().equals(user)){
                return new ResponseEntity<>(
                        CommonErrors.WRONG_USER,
                        HttpStatus.FORBIDDEN);
            }
        } else {
            Optional<guestUser> guestOPT = guService.getCheckAndExtendById(guestId);
            if (guestOPT.isEmpty()){
                return new ResponseEntity<>(
                        CommonErrors.USER_NOT_FOUND,
                        HttpStatus.BAD_REQUEST
                        );
            }
            guestUser guest = guestOPT.get();
            if (!vote.getGuest().equals(guest)){
                return new ResponseEntity<>(
                        CommonErrors.WRONG_USER,
                        HttpStatus.FORBIDDEN
                        );
            }
        }

       if (!service.deleteVoteById(id)){
            return new ResponseEntity<>(
                    CommonErrors.NOT_DELETED,
                    HttpStatus.INTERNAL_SERVER_ERROR
                    );
       }
       return new ResponseEntity<>(vote,HttpStatus.OK);
    }

    @PostMapping
    public ResponseEntity<?> createVote(@RequestBody Vote createdVote,
            @RequestHeader(value = "GuestId", required = false) 
            String guestId,
            Authentication authentication){
        //Checks that there is some form of authentication
        if (authentication == null && guestId == null){
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
        //Handles the request if the auth is a JWT token
        if (authentication != null){
            Jwt token = (Jwt) authentication.getPrincipal();
            String username = token.getClaimAsString("sub");
            Optional<User> userOpt = userService.getUserByUsername(username);
            if (userOpt.isEmpty()){
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(new ResourceNotFoundException("Could not find user with username: " + username));
            }
            User user = userOpt.get();
            createdVote.setUser(user);
            Optional<Vote> existingVote = service.findUserVoteOnPoll(user, createdVote);
            //If the user already has a vote on this poll
            if (existingVote.isPresent()){
                Vote oldVote = existingVote.get();
                Vote vote = service.updateVote(oldVote.getId(), createdVote)
                    .orElseThrow(() -> new OperationFailedError("Could not update Vote"));
                return new ResponseEntity<>(vote, HttpStatus.CREATED);
            }
            //Handles the request if the authentication is a guest-id header
        } else {
            Optional<guestUser> guestUser = guService.getCheckAndExtendById(guestId);
            if (guestUser.isEmpty()){
                return new ResponseEntity<>(
                        CommonErrors.WRONG_USER,
                        HttpStatus.NOT_FOUND
                        );
            }
            guestUser guest = guestUser.get();
            createdVote.setGuest(guest);
            Optional<Vote> existingVote = service.findGuestVoteOnPoll(guest, createdVote);
            //If the guestid already has a vote on this poll
            if (existingVote.isPresent()){
                Vote oldVote = existingVote.get();
                Vote vote = service.updateVote(oldVote.getId(), createdVote)
                    .orElseThrow(() -> new OperationFailedError("Could not update Vote"));
                return new ResponseEntity<>(vote, HttpStatus.CREATED);
            }
        }

        Vote vote = service.addVote(createdVote);
        if (vote == null){
            return new ResponseEntity<>(
                    CommonErrors.POLL_EXPIRED,
                    HttpStatus.NOT_FOUND
                    );
        }
        return new ResponseEntity<>(vote, HttpStatus.CREATED);
            }


    // @PutMapping("/{id}")
    // public ResponseEntity<Vote> updateVote(@PathVariable("id") Long id,
    //         @RequestBody Vote updatedVote){
    //     Optional<Vote> updated = service.updateVote(id, updatedVote);
    //     if (updated.isEmpty()){
    //         return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    //     }
    //     return new ResponseEntity<>(updated.get(), HttpStatus.OK);
    // }
}
package no.hvl.dat250.polls.controllers;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import no.hvl.dat250.polls.Services.VoteOptionService;
import no.hvl.dat250.polls.models.VoteOption;

/**
 * VoteOptionsController 
 * @author Jonas Vestbø
 */
@RequestMapping("/api/voteoptions")
@RestController
public class VoteOptionsController {
    
    @Autowired VoteOptionService service;

    @GetMapping
    public ResponseEntity<List<VoteOption>> getAllVoteOptions(){
        List<VoteOption> allVoteOptions = service.getAllVoteOptions();
        if (allVoteOptions == null || allVoteOptions.isEmpty()){
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }
        return new ResponseEntity<>(allVoteOptions, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<VoteOption> getVoteOption(@PathVariable("id") Long id){
        Optional<VoteOption> retrievedVoteOption = service.getVoteOptionById(id);
        if (retrievedVoteOption.isEmpty()){
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
        return new ResponseEntity<>(retrievedVoteOption.get(), HttpStatus.OK);
    }

    @PostMapping
    public ResponseEntity<VoteOption> addVoteOption(@RequestBody VoteOption voteOption){
        VoteOption savedVoteOption = service.addVoteOption(voteOption);
        return new ResponseEntity<>(savedVoteOption, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<VoteOption> deleteVoteOption(@PathVariable("id") Long id){
        Optional<VoteOption> retrievedOption = service.getVoteOptionById(id);
        if (retrievedOption.isEmpty()){
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
        if (!service.deleteVoteOptionById(id)){
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
        Optional<VoteOption> retrievedOption2 = service.getVoteOptionById(id);
        if (retrievedOption2.isEmpty()){
            System.out.println("Deleted");
        } else {
            System.out.println("Not deleted");
        }
        return new ResponseEntity<>(retrievedOption.get(), HttpStatus.OK);
    }

    @PutMapping("/{id}")
    public ResponseEntity<VoteOption> udpateVoteOption(@PathVariable("id") Long id,
            @RequestBody VoteOption updated){
            Optional<VoteOption> updatedVoteOption = service.updateVoteOption(id, updated);
            if (updatedVoteOption.isEmpty()){
                return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
            }
            return new ResponseEntity<>(updatedVoteOption.get(), HttpStatus.OK);
    }
}
package no.hvl.dat250.polls.controllers;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import no.hvl.dat250.polls.Services.GuestUserService;
import no.hvl.dat250.polls.models.guestUser;

/**
 * GuestController
 */
@RequestMapping("/api/guest")
@RestController
@CrossOrigin
public class GuestController {

    @Autowired GuestUserService service;

    @PostMapping
    public ResponseEntity<guestUser> registerUserRepository(){
        guestUser newUser = service.registerGuestUser();
        return new ResponseEntity<>(newUser, HttpStatus.CREATED);
    }
}
package no.hvl.dat250.polls.controllers;

import java.util.List;
import java.util.Optional;
import no.hvl.dat250.polls.Services.UserService;
import no.hvl.dat250.polls.dto.UserCreationDTO;
import no.hvl.dat250.polls.models.User;
import no.hvl.dat250.polls.Error.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


/**
 * UserController
 * @author Jonas Vestbø
 */

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    UserService service;

    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> allUsers = service.getAllUsers();
        if (allUsers == null || allUsers.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<>(allUsers, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> getUserById(@PathVariable("id") Long id) {
        Optional<User> retrievedUser = service.getUserById(id);
        if (retrievedUser.isEmpty()) {
            return new ResponseEntity<>(CommonErrors.USER_NOT_FOUND, HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<>(retrievedUser.get(), HttpStatus.OK);
    }

    @PostMapping
    public ResponseEntity<User> addUser(@RequestBody UserCreationDTO user) {
        User savedUser = service.addUser(user);
        return new ResponseEntity<>(savedUser, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteUserById(@PathVariable("id") Long id) {
        Optional<User> retrievedUser = service.getUserById(id);
        if (retrievedUser.isEmpty()) {
            return new ResponseEntity<>(
                    CommonErrors.USER_NOT_FOUND,
                    HttpStatus.NOT_FOUND
                    );
        }
        if (!service.deleteUserById(id)) {
            return new ResponseEntity<>(
                    CommonErrors.NOT_DELETED,
                    HttpStatus.INTERNAL_SERVER_ERROR
                    );
        }
        return new ResponseEntity<>(retrievedUser.get(), HttpStatus.OK);
    }

    // Unnesscesary
    // @DeleteMapping
    // public ResponseEntity<User> deleteUserById(@RequestBody User user){
    //     Optional<User> retrievedUser = service.getUserById(user.getId());
    //     if (retrievedUser.isEmpty()){
    //         return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    //     }
    //     if (!service.deleteUser(user)){
    //         return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
    //     }
    //     return new ResponseEntity<>(retrievedUser.get(), HttpStatus.OK);
    // }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateUser(
        @PathVariable("id") Long id,
        @RequestBody User updUser
    ) {
        Optional<User> updatedUser = service.updateUser(id, updUser);
        if (updatedUser.isEmpty()) {
            return new ResponseEntity<>(
                    CommonErrors.USER_NOT_FOUND,
                    HttpStatus.NOT_FOUND
                    );
        }
        return new ResponseEntity<>(updatedUser.get(), HttpStatus.OK);
    }
    // @PostMapping("/users")
    // public ResponseEntity<User> createUser(@RequestBody User user) {
    //     userService.addUser(UserCreationDTO(user));

    //     return ResponseEntity.ok(user);
    // }
}
